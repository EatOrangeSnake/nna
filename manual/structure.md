# 概括
本文主要介绍**NNA**类型的结构，并评价这个结构的特点与好处。
# 结构本质
**NNA**结构的本质其实就是一段内存
## C语言结构体表示
```c
sturct NNA {
    unit (*body) [];
    size_t length;
}; // 标准的自然数数组数据类型
```
- `unit`就是成员类型，一般会选择字节作为`unit`。在常见的计算机硬件设计中，C语言一般为`char`，Rust语言一般为`u8`。单独引用则会标注为***NNAUnit***。
- `body`其实才是NNA类型的核心，单独引用则会标注为***NNABody***。
- `size_t`这其实是**NNABody**数组指针的长度。
如果你这么了解，你就会知道，这其实就是一个向量。用C语言表示就是`std::vector<unit>`，用Rust语言表示就是`Vec::<unit>`。
# 数字功能的实现原因
## 关键概念
其实数据结构和数据表示之间就是一个映射关系。这就是所有数字类型表达的原理。为了方便讲解，先提出几个概念：
- ***结构值***：一种数列，一般用数学符号$S$表示。指在内存中存储的结构的值。用$S_i$表示在索引$i$处的成员的值。（**索引从0开始。**）
- ***数字值***：一种数字，一般用数学符号$N$表示。指某个*结构值*所表示的数。
- ***进位临界值***：指的是当一个数字超出某些数据类型的结构表达范围时就会发生进位，尝试将多余的部分转移到其他数据上以防止出现数字表达上的错误。而一旦达到进位临界值就会发生进位，进位临界值一般用数学符号$C$表示。$C(T)$就是指`T`类型的进位临界值。
- ***范围映射***：一种映射，一般用数学符号$F$表示。**从*结构值*映射到*数字值*，最好尽可能将空间利用率提升到100%.**，$F(S)$表示$S$对应的$N$，可能有多个。
- ***空间利用率***：一种比率，一般用数学符号$\rho$表示，用于衡量数据类型利用空间的能力。$\rho \in (0,1]$，越大说明该数据类型越能利用空间。具体的讲解可以查看文档[NNA的扩展功能——空间利用率](./space-using-rate.md)。**绝对标准的*NNA*的*空间利用率*一定是100%.**
## 数字表达的奥秘
你肯定会对数字的表达提出疑惑，向量怎么能表达数字呢？我们先找一下灵感！
### 基本数据类型
我们都知道C语言有多个基本类型，这对应了汇编语言的各种大小的数据单位。以下为`unit`进位临界值为256的情况下的一些数据类型[^1]的范围汇总：
|C语言类型名[^2]|Rust语言类型名[^3]|Intel x86-64汇编语言关键字|Intel x86-64汇编语言寄存器名|大小（字节）|进位临界值[^4]|
|:--:|:--:|:--:|:--:|:-:|:---:|
|`void`|`()`|/|/|0|$256^0=1$|
|`uint8_t`|`u8`|`BYTE`|`*h`/`*l`/`r*l`|1|$256^1=256$|
|`uint16_t`|`u16`|`WORD`|`*x`/`r*w`|2|$256^2=65536$|
|`uint32_t`|`u32`|`DWORD`|`e*x`/`r*d`|4|$256^4=4294967296$|
|`uint64_t`|`u64`|`QWORD`|`r*x`/`r*`|8|$256^8=18446744073709551616$|
|`__m64`|`__m64`|/|`mm*`|8|$256^8$|
|`__m128`|`__m128`|/|`xmm*`|16|$256^{16}$|
|`__m256`|`__m256`|/|`ymm*`|32|$256^{32}$|
|`__m512`|`__m512`|/|`zmm*`|64|$256^{64}$|

[^1]:为了表达原理，该表只挑取了部分最具有代表性的无符号数据类型。
[^2]:这里的`void`实则无法运算，这里只是为了给出个空类型方便对比；这里的SIMD类型只有结构功能，同样为了对比而加入，这里需要包含`<immintrin.h>`；这里的基本数据类型只有数字功能，需要包含`<stdint.h>`。
[^3]:这里的`()`仅仅有结构功能，这里只是为了给出个空类型方便对比；这里的SIMD类型只有结构功能，同样为了对比而加入，这里需要使用`std::arch::x86_64`的命名空间；这里的基本数据类型只有数字功能。
[^4]:一个数据类型大于等于***进位临界值***会触发进位。（由于`void`类型和SIMD类型实际上只有结构功能，但这里也当成了数字处理进位。）

那这似乎和我们的主题没关系啊？别着急，我们现在就来找找规律，或许会有新的发现。
## 范围映射
我们重点关注常见基本类型的范围映射，从这里找找规律（设进位临界值为256用于匹配常见的byte）：
### 单成员基本类型
|示例C语言类型|成员类型的进位临界值|结构值|数字值|
|:-:|:--:|:--:|:--:|
|`uint8_t`|$C_0 \ge 0$|$\{0\}$|$0$|
|`uint8_t`|$C_0 \ge 1$|$\{1\}$|$1$|
|`uint8_t`|$C_0 \ge 2$|$\{2\}$|$2$|
|`uint8_t`|$\cdots$|$\cdots$|$\cdots$|
|`uint8_t`|$C_0 \ge 0$|$\{n\}, n \le C, n \in \mathbb{N}$|$n$|

*进位临界值*：$C_0$

我们不难发现，实际上的单成员基本类型（例如`byte`）结构的数字值就是结构值的那唯一一个成员。
### 双成员基本类型
例如`word`：
|示例C语言类型|成员类型的进位临界值|结构值|数字值|
|:-:|:--:|:--:|:--:|
|`uint16_t`|$C_0 \ge 0, C_1 \ge 0$|$\{0, 0\}$|$0$|
|`uint16_t`|$C_0 \ge 1, C_1 \ge 0$|$\{1, 0\}$|$1$|
|`uint16_t`|$C_0 \ge 2, C_1 \ge 0$|$\{2, 0\}$|$2$|
|`uint16_t`|$\cdots$|$\cdots$|$\cdots$|
|`uint16_t`|$C_0 \ge 0, C_1 \ge 0$|$\{n, 0\}, n \le C_0, n \in \mathbb{N}$|$n$|
|`uint16_t`|$C_0 \ge 0, C_1 \ge 1$|$\{0, 1\}$|$C_0$|
|`uint16_t`|$C_0 \ge 1, C_1 \ge 1$|$\{1, 1\}$|$C_0 + 1$|
|`uint16_t`|$C_0 \ge 2, C_1 \ge 1$|$\{2, 1\}$|$C_0 + 2$|
|`uint16_t`|$\cdots$|$\cdots$|$\cdots$|
|`uint16_t`|$C_0 \ge 0, C_1 \ge 1$|$\{n, 1\}, n \le C_0, n \in \mathbb{N}$|$C_0+n$|
|`uint16_t`|$C_0 \ge 0, C_1 \ge 2$|$\{0, 1\}$|$2C_0$|
|`uint16_t`|$C_0 \ge 1, C_1 \ge 2$|$\{1, 1\}$|$2C_0 + 1$|
|`uint16_t`|$C_0 \ge 2, C_1 \ge 2$|$\{2, 1\}$|$2C_0 + 2$|
|`uint16_t`|$\cdots$|$\cdots$|$\cdots$|
|`uint16_t`|$C_0 \ge 0, C_1 \ge 2$|$\{n, 1\}, n \le C_0, n \in \mathbb{N}$|$2C_0+n$|
|`uint16_t`|$C_0 \ge 0, C_1 \ge 0$|$\{0, n\}, n \le C_1, n \in \mathbb{N}$|$nC_0$|
|`uint16_t`|$C_0 \ge 1, C_1 \ge 0$|$\{1, n\}, n \le C_1, n \in \mathbb{N}$|$nC_0 + 1$|
|`uint16_t`|$C_0 \ge 2, C_1 \ge 0$|$\{2, n\}, n \le C_1, n \in \mathbb{N}$|$nC_0 + 2$|
|`uint16_t`|$\cdots$|$\cdots$|$\cdots$|
|`uint16_t`|$C_0 \ge 0, C_1 \ge 0$|$\{m, n\}, m \le C_0, n \le C_1, m \in \mathbb{N}, n \in \mathbb{N}$|$nC_0 + m$|

*进位临界值*：$C_0C_1$

对比这个表格，你就能更好地理解*进位临界值*这个概念了。
这下你知道为什么我要将`void`和SIMD类型也加入进去了吧？表中列举出的数据类型其实都可以看作0/1/2/4/8/16/32/64成员长度的特殊大数。
这样子，我们就可以将这些逻辑逐渐推广下去，就得到了我们**第一版的大数类型**。
### 早已应用
其实这就是很多基本大数库采用的数据结构，已经开始使用了。我们将这种类型称为*NNT*，但这并不是*NNA*，我们介绍的是全新的大数类型*NNA*，所以我们必须进行扩展和改良。
## 更进一步
为什么需要进一步扩展呢？这是因为这种大数类型其实是有上限的。大家都看到了，这些大数仍然有*进位临界值*。这意味着**这些大数仍然会进位**，也就意味着有范围上限。
为什么会导致这个结果？仔细思考就会明白，空间就只有那么大，自然不会装下无限的自然数。
那么干脆就把所有存储器的空间全部作为*NNABody*？听起来确实很诱人，毕竟$256^{2^{64}}$这个进位临界值简直就是天文数字中的天文数字！但理想很丰满，现实太骨感——我们不可能将这么大的空间都用于*NNA*的数据体，哪怕少一些也不现实。所以这种想法在梦里想想就好了，没准还能梦到无限存储器直接突破理论无限呢？哈哈！
这下你知道为什么NNA数据类型是向量结构了吧？为什么将数据类型设为可变长度的，用数据体表示大数？就是因为这才是目前的最优解。不仅**保留了无上限的大数优点，而且可行且不会过于消耗计算机资源**。不过仍有缺点：只能说**达到了理论上限，实际上非常受限于存储器硬件和内存分配器**。毕竟想要无限存储器你得和硬件工程师打一架，哈哈！
最后无论是什么大数设计，**只要没有硬件支持，基本都远远比不上基本类型与SIMD类型的效率**。所以不要随意使用包括*NNA*在内的任何大数库哦！不过在开发设计时会使用各种技术尽可能地加速，到时请看文档[NNT关键技术](technology.md)。
## NNA的出现
那么具体该怎么表示呢？我们先试一下：
### 第二版
|结构值|数字值|
|:-:|:-:|
|$\{\}$|$0$|
|$\{0\}$|$0$|
|$\{1\}$|$1$|
|$\{2\}$|$2$|
|$\cdots$|$\cdots$|
|$\{0, 0\}$|$0$|
|$\{1, 0\}$|$1$|
|$\{2, 0\}$|$2$|
|$\cdots$|$\cdots$|
|$\{0, 0, 0\}$|$0$|
|$\{1, 0, 0\}$|$1$|
|$\{2, 0, 0\}$|$2$|
|$\cdots$|$\cdots$|

是不是发现问题了！**范围映射$F$出现了大量多对一的情况。这就导致很多结构值的编码都被浪费了**，因为它们完全可以只被一个结构值表达。那么有没有解决方案呢？
### 经典案例
大家肯定都知道反码和补码的区别。为什么需要补码？就是因为有两个结构值对应0,分别被称为正零和负零。为了扩展表达范围，直接将负数表达范围向前移一。此方法不仅只保留了正零以消除范围映射多对一的问题，而且还顺便为负数表达范围新增了一个数，真是个好方法！而我们要做的就是效仿这个经典案例，**尽可能调整数字值至最小，调整结构值至大小最小、最紧凑、一一映射的范围。**
### 最佳规划
我们尝试从*NNT*开始，假设可以变成不同长度的*NNT*，多角度分析问题：
- 从最小的角度分析，*NNT*都是固定大小的，因此不考虑这个因素。
- 从最紧凑的角度分析，*NNT*已经将所有可用的结构值全部映射到数字值了。
- 从一一映射的角度分析，原码的*NNT*严格符合要求。
这也证明了我们的第二版出现问题的原因就是将多个*NNT*的表达范围大量地进行了重叠。

那么我们就把它们分开，并尽可能调整至大小最小、最紧凑的一一映射的范围。
没错！按照NNT的长度从小到大**将每个*NNT*的表达范围紧紧拼接**，拼接后**第二个*NNT*的偏移就会加上第一*NNT*的进位临界值**，然后循环下去，形成映射，那样就完美满足要求了。这么说可能有些抽象，对照一下表格就能理解了。（$C$为每个成员的进位临界值。）

|结构值|原来的组合值|改进的组合值|
|:----:|:-:|:-:|
|$\{\}$|$0$|$0$|
|$\{a\}, a \le C, a \in \mathbb{N}$|$aC^0$|$aC^0 + C^0$|
|$\{a, b\}, a \le C, b \le C, a \in \mathbb{N}, b \in \mathbb{N}$|$aC^0+bC^1$|$aC^0+bC^1 + C^0+C^1$|
|$\{a, b, c\}, a \le C, b \le C, c \le C, a \in \mathbb{N}, b \in \mathbb{n}, c \in \mathbb{n}$|$aC^0+bC^1+cC^2$|$aC^0+bC^1+cC^2 + C^0+C^1+C^2$|
|$\cdots$|$\cdots$|$\cdots$|
|$\{a_n\}$|$\sum_{i=0}^{n-1}a_iC^i$|$\sum_{i=0}^{n-1}a_iC^i+\sum_{i=0}^{n-1}C^i$|
### 第三版
至此，*NNA*的结构设计正式完成！
# 总结
正是因为这种特殊设计，才能在压缩领域有重要作用。