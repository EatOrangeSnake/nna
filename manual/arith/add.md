# 概括
本文主要实现 ***NNA(Natural Number Array)*** 数据结构的加法运算。
# 数学基础
加法可是数学基础中的基础啊！要是某个大数库连这加法都搞不定，就别叫大数库了。
# 阅读前提
建议先读[数据结构](../structure.md)和[进位思路](./inc.md)。
# 数学理论
## 数字转换
根据*NNA*的表达方式，可以得到以下算式：
$$F(S)=\sum_{i=0}^{n-1} S_iC^i+\sum_{i=0}^{n-1} C^i$$
## 数字值加法推演
那么如果是两个*NNA*相加，数字值也应该相加，那么其结构值又有什么变化呢？
设有两个*NNA*$a$和$b$，那么该如何计算呢？
$$
F(S_a)=V_a=\sum_{i=0}^{n-1} {S_a}_iC^i+\sum_{i=0}^{n-1} C^i\\
F(S_b)=V_b=\sum_{i=0}^{n-1} {S_b}_iC^i+\sum_{i=0}^{n-1} C^i\\
V=F(S_a+S_b)=V_a+V_b
=\sum_{i=0}^{n-1} {S_a}_iC^i+\sum_{i=0}^{n-1} C^i+\sum_{i=0}^{n-1} {S_b}_iC^i+\sum_{i=0}^{n-1} C^i
=\sum_{i=0}^{n-1} ({S_a}_i+{S_b}_i+2)C^i
$$
最终的结果就是$V=V_a+V_b=\sum_{i=0}^{n-1} ({S_a}_i+{S_b}_i+2)C^i$。
注意了，为什么需要化简为这种形式呢？这其实是为了方便我们以后的算法。因为但凡有一个求和项没有归为同一个，就需要在具体实现时重复遍历，这绝对是**对性能的极大影响因素！**
如果你贸然化简为类似于$V=V_a+V_b=\sum_{i=0}^{n-1} ({S_a}_i+{S_b}_i+1)C^i+\sum_{i=0}^{n-1} C^i$的形式，就意味着**需要在原加法的时候再进行一次加法，会严重影响性能（缓存未命中、复杂度翻倍）。**
## 结构值转换
那么既然有了公式，就可以直接通过遍历运算来进行计算了吗？别着急，结构值的所有成员都需要小于$C$。那么实际每个成员的计算公式是什么呢？
$$
\begin{aligned}
    S=&F^{-1}(V)\\
    =&F^{-1}(\sum_{i=0}^{n-1} ({S_a}_i+{S_b}_i+2)C^i)\\
    =&F^{-1}(\sum_{i=0}^{n-1} ({S_a}_i+{S_b}_i+1)C^i+\sum_{i=0}^{n-1} C^i)\\
    S_i=&{S_a}_i+{S_b}_i+1
\end{aligned}
$$
我们计算一下此时某个成员的取值范围。
$$
\because {S_a}_i \in \{x \in \mathbb{N}|x \lt C\},
{S_b}_i \in \{x \in \mathbb{N}|x \lt C\},
S_i={S_a}_i+{S_b}_i+1\\
\therefore S_i \in \{x \in \mathbb{N}|x \lt 2C\}\\
\therefore {S_i}_{max}=2C-1
$$
但这是不考虑进位的情况，如果需要考虑进位，情况会更复杂。我们假设进位标志为$c$：
$$
\because {S_a}_i \in \{x \in \mathbb{N}|x \lt C\},
{S_b}_i \in \{x \in \mathbb{N}|x \lt C\},
c \in \{0,1\},S_i={S_a}_i+{S_b}_i+1\\
\therefore S_i \in \{x \in \mathbb{N}|x \lt 2C+1\}\\
\therefore {S_i}_{max}=2C
$$
发现了什么？是不是会有需要进位的情况。因为**每个成员必须小于$C$，然而加法运算后会出现大于等于$C$的情况。**更重要的是，**可能还会出现进二的特殊情况，因为可被进位的索引位置的最大值可以达到$2C$。且是在${S_a}_i$、${S_b}_i$、$c$都达到最大时才会出现。**因此我们还需要再次修正计算过程：
$$
\because {S_a}_i \in \{x \in \mathbb{N}|x \lt C\},
{S_b}_i \in \{x \in \mathbb{N}|x \lt C\},
c \in \{0,1,2\},S_i={S_a}_i+{S_b}_i+1\\
\therefore S_i \in \{x \in \mathbb{N}|x \lt 2C+2\}\\
\therefore {S_i}_{max}=2C+1
$$
**进位的可能情况并没有再发生变化，因此不需要进行更改了。**
## 其他情况
那么如果两个*NNA*长度不一样，那么总有一个*NNA*会有多出的部分，那么多出的部分该怎么计算呢？更简单了，我们假设多处的部分属于$S_a$，并在$s$处开始：
$$
V=F(S)=V_a+c=F(S_a)+c=
\sum_{i=s}^{n-1} {S_a}_iC^i+\sum_{i=s}^{n-1} C^i+c
$$
我们加入每一位的进位就可以得到：
$$
V=F(S)=V_a+c=F(S_a)+c=
\sum_{i=s}^{n-1} ({S_a}_i+c)C^i+\sum_{i=s}^{n-1}
$$
计算范围与临界值：
$$
\because {S_a}_i \in \{x \in \mathbb{N}|x \lt C\},c \in \{0,1,2\},S_i={S_i}_0+c\\
\therefore S_i \in \{x \in \mathbb{N}|x \lt C+2\}\\
\therefore {S_i}_{max}=C+1
$$
我们不难发现，因为**进位可能会进二，因此不能简单地用自增算法。**
## 尾部进位处理
都逐对加完了但仍然有进位需要处理。那么我们也推导一下吧，假设进位到了索引$i$，进位是$c$，那么这次进位的数值则是$cC^i$。我们化简为结构值：
$$
F^{-1}(cC^i)=F^{-1}((c-1)C^i+C^i)=\{0 \cdots (\text{重复i-1次}),c-1\}
$$
那么如果进位为$0$呢？总不能使用负数作为进位后的成员吧？那就更简单了，就不进位了，因为满不了$C^i$就根本进不了位。