# 概括
本文主要介绍了*NNA*类型的自增操作以及实现设计，着重讲解自增算法对*NNA*算法带来的意义。
# 数学之源
人类的数学起源就是数数，通过自增（加一）逐渐扩展到自然数，自然数才成为了人类第一次认识到的数集，这也是很多数学公理体系为了将数集延展至自然数的一种方法。在计算机学中，自增也是一种快速的计数操作。尽管很多时候我们会使用加法，但对于*NNA*算法的意义却很重大，因此特意实现这样的一个算法。
# 阅读准备
读完[数据结构](../../structure.md)理解起来会更容易。
# 映射表
为了实现自增操作，我们必须要找到计算的流程。那么这个流程该在哪里找呢？没错！**映射的时候就是一步步地将*结构值*映射到不同的依次自增的*数字值*的**。那么我们先记录几个在*进位临界值*为256的情况下进位的临界情况吧！
|结构值|被进位的结构值索引|是否即将进位|是否进位|
|:---:|:--:|:-:|:-:|
|$\{\}$|0|是|否|
|$\{0\}$|0|否|是|
|$\cdots$|/|/|/|
|$\{255\}$|0|是|否|
|$\{0, 0\}$|0,1|否|是|
|$\cdots$|/|/|/|
|$\{255, 0\}$|0|是|否|
|$\{0, 1\}$|0,1|否|是|
|$\cdots$|/|/|/|
|$\{255, 255\}$|0|是|否|
|$\{0, 0, 0\}$|0,1,2|否|是|
|$\cdots$|/|/|/|
|$\{255, 0, 0\}$|0|是|否|
|$\{0, 1, 0\}$|0,1|否|是|
|$\cdots$|/|/|/|
|$\{255, 255, 0\}$|0|是|否|
|$\{0, 0, 1\}$|0,1,2|否|是|
|$\cdots$|/|/|/|

准确来说，进位是这样的：
1. **在本索引加一对应的值。**
2. **如果结果大于等于$C$，那么在下一索引的位置重复操作1.**
3. **如果下一个索引不存在，那么就在原结构值后面追加一个$0$。**
你可能会好奇为什么索引0的位置会被进位。那是因为**自增时映射表中对应的结构值的第一位总是会自增，这里也归类为了进位**，这样就把自增的算法理论统一了起来。我们观察一下：
- **进位的索引总是从0开始的连续自然数**。这是因为自增操作就是从索引0开始被进位的，进位之后可能也只可能引发下一位的进位。
- **当*NNA的结构值*在某个索引的值等于$C-1$，那么就会在这个索引的位置发生进位，进位后等于$0$**。
这些都是关键结论！因为这很有可能会有助于我们优化代码。但不一定要用，具体使用哪些结论根据具体情况而定。
# 意义
为什么意义重大？因为自增操作本身就是在索引0的位置触发了进位，**然而进位在很多*NNA*操作都极其常见。**
因为*NNA*的很多操作都需要将几个不同的*NNA*的一些`Unit`进行匹配，然后可能会携带进位带到下一位的进位中。然而*NNA*是不定长的，经常会遇到匹配完毕但其他*NNA*还有剩余的情况，而之前的进位仍然需要处理。因此就需要在那一位进行进位。虽然不需要调用自增操作，但可以参考进位的流程。