# 概述
讲述了*NNA(Natural Number Tuple)*支持哪些算法，并且介绍了一些优化策略。
# 算术文档链接
啥都别说了，自己先挑看哪个吧：

算术：
- [加法](add.md)
- [减法](sub.md)
- [乘法](mul.md)
- [除法](div.md)
- [自增](inc.md)
- [自减](dec.md)
压缩：
- [标准聚合](compress.md)
- [标准分解](compress.md)
转换：
- [从字节](tran.md)
- [到字节](tran.md)
- [从半字](tran.md)（在以双字节为字的架构中直接指字节操作。）
- [到半字](tran.md)（在以双字节为字的架构中直接指字节操作。）
- [从字](tran.md)
- [到字](tran.md)
- [从双字](tran.md)
- [到双字](tran.md)
- [从四字](tran.md)
- [到四字](tran.md)
字符串操作：
- [数字文本化](str.md)
- [文本数字化](str.md)
- [格式文本化](str.md)
调试操作：
- [文本调试化](dbg.md)
# SIMD
SIMD是对于遍历问题非常通用的一种方法，对*NNA*也很适用。不过在x86-64架构中这样固定SIMD寄存器的架构中需要考虑对齐和尾部处理问题。根据*NNA*数与数组共存的双性质，而且会经常遇到长*NNA*，因此推荐**使用对齐和尾部处理**。
# 专用处理器
此外，使用*GPU*、*TPU*这类专用处理器可能是更好的选择。只需要协调好存储和并发，就可以尽可能地发挥出意想不到的潜力。
# 异步流水线
我们不难发现，很多算术操作都需要遍历，而**遍历往往是非常耗时的操作，因为遍历会使时间复杂度线性增长，嵌套遍历甚至会使时间复杂度幂增长**。而很多NNA应用场景尤其是*NNA*压缩操作**所需的算法调用都非常多，这就会极其影响效率**。因此可以使用异步的方式解决。但是这里**必须使用锁以避免出现不必要的麻烦，而且不能是一般的锁，必须保证某一字节的操作顺序相同。**这其实是个序列操作通用的优化手段，有专门开发的项目，以后会给大家介绍。